# This is an example padframe config file that showcases most of Padricks
# features. It is not the cleanest and most readable example but contains
# extensive documentation of the features in action. Have a look at some of the
# other config files for a reference how a minimal config file for your SoC
# could look like.
name: low_power_padframe # This name is used as the prefix for all
                         # auto-generated modules to avoid naming conflicts in
                         # case multiple padframes are generated.n
manifest_version: 3
user_attr: # This is an option entry where you can add custom key value pairs.
           # These key-value pairs are also exposed during template rendering so
           # you can refer to them in customized templates. They also come in
           # handy if you need to parametrize certain aspects of your config
           # file, e.g. the number of pads. You can use YAML anchors and aliases
           # to refer to those parameters.
  gpio_count: &gpio_count 32
pad_domains:
  - name: always_on_pads # User defined name of the pad_domain
    pad_types: # This section contains a list of pads
      - name: pull_down_pad # user defined name of the pad. Used to reference it
                            # in the pad_list
        description: TSCM65 pad with controllable integrated 1kOhm pull down resistor
        # The template value is a Mako template (https://www.makotemplates.org/)
        # that specifies how to instantiate this partuclar pad. The '|' in the
        # beginning is YAML syntax to allow multiline strings without the need
        # for manual character escaping
        template: |
          PDDW04808 ${instance_name} (
            .PAD(${conn["pad"]}),
            .IE(${conn["rx_en"]}),
            .OE(${conn["output_en"]}),
            .DS(${conn["driving_strength"]}),
            .I(${conn["chip2pad"]}),
            .O(${conn["pad2chip"]})
          );

        pad_signals: &default_pad_signals #This is a YAML anchor to reuse a subblock somewhere else. Use it to avoid copy paste hell!
        # The pad signals section specifies a list of all pad signald used in
        # this particular pad_domain. This include the rx signal, tx signal, the
        # actual pad signal as well as all pad configuration signals. These are
        # the signals that can be referenced by name in the pad instantiation
        # templates within the pad_types sections, the connections of each pad
        # within the pad_list as well as the connections section in the
        # port_list.
          - name: output_en
            description: "Enables the output driver of the pad" #optional description
                                                         #of the signal
            size: 1 # The number of bits
            kind: input # The signal is an input signal to the pad i.e. a signal
                        # driven by the chip that controls the pad.
            conn_type: dynamic # This means, the signal value is dynamic. It can
                               # either be controlled by an autogenerated
                               # configuration register or (at runtime
                               # configurable) an IO signal (if any IO signal
                               # within the pad_domain is referencing it).
            or_override_signal: s_enable_all_outputs # Optional override signal
                                                      # that is and-gated with
                                                      # the control signal
            default_reset_value: 0 # The default reset value of the pad
                                      # signal if not overriden in the
                                      # "connections" section of a particular
                                      # pad instance
            default_static_value: 1'b0 # The default static value of the signal
                                       # if not overriden in the "connections"
                                       # section of a particular pad instance
          - name: driving_strength
            description: "Driving strength of the output driver"
            size: 3
            kind: input
            conn_type: static # This means, the signal has a static value that
                              # is either driven by a single signal or a
                              # constant value. The difference between the
                              # dynamic type is, that this pad_signal is not
                              # arbitrary connectable with IO signals in a
                              # crossbar fashion but tied to one dedicated
                              # signal only. The actual signal or value assigned
                              # is defined individually for each pad in the
                              # padlist or described globally with the
                              # default_static_value.
            default_reset_value: 0
            default_static_value: 3'b0
          - name: rx_en
            description: "Input buffer enable"
            size: 1
            kind: input
            conn_type: dynamic
            default_reset_value: 0
            default_static_value: 1'b0
          - name: pad2chip
            description: "The signal that connects to the pads RX buffer"
            size: 1
            kind: output
            conn_type: dynamic # In case of static output pad_signals, literal
                               # value assignments are illegal since the signal
                               # is not drivable from the outside. Only the name
                               # for a dedicated padframe output signal can be
                               # specified.
            default_static_value: ~
          - name: chip2pad
            description: "The signal that connects to the pads TX driver"
            size: 1
            kind: input
            conn_type: dynamic
            default_reset_value: 1
            default_static_value: 1'b0
          - name: pad # The name of the signal can be chosen arbitrarily but for
                      # the actual pad signal (the signal that connects to the
                      # bonding pads) the name "pad" is a good choice. It is
                      # legal to specify more than one signal of type pad (e.g.
                      # if you want to instantiate a special differential
                      # signaling pads ). However, at least one siganl of kind
                      # pad is required
            size: 1
            kind: pad # Pad signals are handled specially. They are always
                      # exposed directly to the toplevel of the generated
                      # padframe module and no type, override signals or default
                      # values are allowed.

          - name: pull_up_en
            description: "Enable the pads weak pull-up resistor"
            size: 1
            kind: input
            conn_type: dynamic
            default_reset_value: 0
            default_static_value: 1'b0

      - name: low_leakage_pad
        description: Low leakage pad used for low-speed, low poewer applications
        template: |
          //This is a System Verilog comment for pad instance ${instance_name}
          PDLL0206 ${instance_name} (
          \  .Z(${conn["pad"]}),
          \  .I(${conn["pad2chip"]}),
          \  .O(${conn["chip2pad"]})
          );
        pad_signals: *default_pad_signals #Use YAML reference to avoid cumbersome duplication of common pad_signal lists
    pad_list:
      - name: pad_ref_clk # The instance name of the pad. 
        description: "32kHz reference clock" #Optional description of the pads function
        pad_type: pull_down_pad
        is_static: true # Declaring a whole pad as static overrides every single
                        # pad signal's conn_type for that particular pad
                        # instance to "static".
        connections: # A list of static pad signal connections (for static
                     # signals) or default config register values (for dynamic
                     # pad signals)
          pad2chip: ref_clk
          chip2pad: 1'b0
          rx_en: 1'b1 #pad signals of kind "input" any SystemVerilog literal is
                   #valid.
          driving_strength: 3'b0
      - name: pad_gpioa{i}
        mux_groups: [all, self] # Mux groups are arbitrary identifiers that
                                # declares the possible connectivities between
                                # ports and pads. All ports and pads within the
                                # same mux_group can be connected with each
                                # other in an any<->any fashion. By default, all
                                # ports and pads are in the "all" mux_group and
                                # in the "self" mux group. "self" is a special
                                # keyword that is internally expanded to the
                                # name of the pad instance itself (with appended
                                # index in case multiple is > 1). This allows
                                # you implicitly create a mux group for every
                                # instance of a multi pad.
        description: "General Purpose Input and Outpud pads. These pads can be configured to connect to any peripheral pad port."
        multiple: *gpio_count #Generate 32 instances of this pad. Each instance will have
                     #its signal and instance names postfixed with the index
                     #number.
        pad_type: pull_down_pad
        is_static: false #False is the default value, thus explicitly specifying
                         #static as false is optional. With this option, each
                         #pad_signal assumes the declared conn_type.
        default_port: # Choose the port that should be exposed by
                      # default after reset.
          '*': gpio_a.GPIO{i:2d} # '*' means match all expanded pad names
          pad_gpioa0: spi.sck  # mappings are evaluated in order so this one overrides the wildcard mapping above
          pad_gpioa1: spi.csn
          pad_gpioa2: spi.mosi
          pad_gpioa3: spi.miso
      - name: pad_gpiob{i}
        mux_groups: [gpio_setb] # Only ports (or entire portgroups) with this
                                # mux_group can be routed to these pad
                                # instances.
        multiple: 32
        pad_type: pull_down_pad
        is_static: false

    port_groups:
      # A port is a collection of signals intended to be multiplexed to one
      # particular pad within the pad domain. The connectivity is runtime
      # configurable via the pad_frames configuration interface. I.e. an SPI
      # master peripheral exposes the SCK, MOSI, MISO and CS ports. These ports
      # can be routed to an arbitrary pad within the same pad_domain.
      - name: spi
        output_defaults: #For each pad -> SoC port signal you have to specify
                         #what value shall be applied when the port is not
                         #connected to any Pad.
          miso: 1'b0
        ports:
          - name: mosi
            description: "MOSI port of the SPI master peripheral" # An optional description of the signal
            connections:
              # Every port contains a mapping of *dynamic* pad_signal to port signal
              # that are connected to each other, if that particular port is
              # connected to a non-static pad instance. E.g. in default config the
              # GPIO3 pad receives all its signals (actual I/O and pad_config
              # signals) from auto genenrated config registers. However, when the
              # user at runtime connects the mosi port to this pad, the
              # chip2pad signal is supplied by the external mosi.mosi signal,
              # the output_en signal is supplied by !mosi.oen and rx_en is
              # connected to mosi.oen. A dedicated struct is generated for each
              # port. It contains each signal that is referenced at least once on
              # the right-hand side of the 'connections' connection dictionary. Each
              # of those inferred signals is of same bitwidth as the first
              # pad_signal connection it is referenced on the right-hand-side.
              chip2pad: mosi & spi_en
              output_en: ~oen
              rx_en: oen # A port signal may be connected to multiple pad signals, but
              # every pad signal defined in the pad_signals section must be
              # connected to at most one port signal. Unconnected dynamic pad
              # signals are driven by the auto-generated configuration
              # register only. The '~' character can be used to negate the
              # signal connection.
          - name: miso
            connections:
              miso: pad2chip
              rx_en: 1'b1 # You can also use static values for port signals. In that
              # case, the pad_signal is internally tied to the given value
              # whenever that particular port is connected to the pad. Any
              # Verilog literal can be used for this purpose.
              output_en: 1'b0
          - name: sck
            connections:
              chip2pad: sck
              rx_en: 1'b0
              output_en: 1'b1
          - name: csn
            connections:
              chip2pad: csn
              rx_en: 1'b0
              output_en: 1'b1
      - name: i2c
        mux_groups: [gpio_setb] # You can optionally define the mux group of all
                             # ports in the port group without specifying it for
                             # every single port
        output_defaults: 
          sda_i: 1'b0
        ports:
          - name: sda
            description: "Bidirectional I2C SDA signal"
            connections:
              chip2pad: sda_o
              sda_i: pad2chip
              output_en: out_en
              rx_en: ~out_en

          - name: scl
            description: "I2C clock signal"
            connections:
              chip2pad: scl
              rx_en: 1'b0
              output_en: 1'b1
      - name: gpio_a
        output_defaults: "'0" # Instead of defining the output_default for every
                              # pad -> SoC port signal individually you can
                              # define a value that applies to all of them (this
                              # obviously only works if all signals should be
                              # driffen with the same default value).
        ports:
          - multiple: 32 # Sometimes, the ports needed in a particular port
                         # group are extremely repetitive (e.g. definition of 32
                         # GPIO pad signals or data lines of MIPI CPI). For
                         # these cases you can declare multiple ports with a
                         # single port declaration that has the optional
                         # 'multiple' field set. This will cause the port
                         # declaration to expand to multiple individual ports
                         # where every occurence of the string token '{i}' in
                         # 'name', 'description', 'mux_group' and signal
                         # mappings in 'connections' is replaced with an
                         # increasing index (starting from 0)
            name: GPIO{i:2d}
            description: "The signal number {i} of the GPIO peripheral"
            mux_groups: ["pad_gpioa{i}"] # Assign each gpio port to the
                                         # individual ports of pad_gpiob. We
                                         # don't need to mux the gpio port
                                         # signals as they are all identical in
                                         # functionality anyways. This creates a
                                         # one-to-one mapping.
            connections:
              chip2pad: gpio{i}_i # Will be replaced with gpio0_i, gpio1_i, gpio2_i etc. 
              gpio{i}_o: pad2chip
              rx_en: dir{i}_i

